<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: url('Baground.png') center/cover no-repeat fixed;
            margin: 0;
            padding: 20px;
        }

        #gameContainer {
            position: relative;
            background: #2c3e50;
            border-radius: 10px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            overflow: hidden;
            width: 90vmin;
            height: 90vmin;
            max-width: 800px;
            max-height: 800px;
            min-width: 320px;
            min-height: 320px;
        }

        #gameCanvas {
            display: block;
            background: url('PlayGroundGrid.png') center/cover;
            background-size: 100% 100%;
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .hidden {
            display: none !important;
        }

        .button {
            padding: clamp(10px, 2vw, 15px) clamp(30px, 5vw, 40px);
            margin: 10px;
            font-size: clamp(18px, 3vw, 24px);
            font-weight: bold;
            color: white;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
        }

        .button:hover {
            background: #2ecc71;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.6);
        }

        .small-button {
            padding: clamp(8px, 1.5vw, 10px) clamp(20px, 3vw, 25px);
            font-size: clamp(14px, 2vw, 16px);
        }

        .username-label {
            color: white;
            font-size: clamp(16px, 2.5vw, 20px);
            margin-bottom: 10px;
        }

        .highscore-text {
            color: #bdc3c7;
            font-size: clamp(14px, 2vw, 18px);
            margin-top: 20px;
        }

        .info-corner {
            position: absolute;
            bottom: 15px;
            right: 15px;
            text-align: right;
            color: #95a5a6;
            font-size: clamp(10px, 1.5vw, 12px);
        }

        .settings-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .settings-icon:hover {
            transform: rotate(90deg);
        }

        .close-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 30px;
            color: white;
            background: #e74c3c;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
            transition: all 0.3s;
        }

        .close-button:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        .leaderboard-list {
            margin-top: 30px;
            width: clamp(300px, 70vw, 400px);
            max-width: 90%;
            max-height: 50vh;
            overflow-y: auto;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: clamp(10px, 1.5vw, 12px) clamp(15px, 2vw, 20px);
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: clamp(12px, 1.8vw, 14px);
        }

        .leaderboard-item.top3 {
            font-weight: bold;
            color: white;
            background: rgba(255, 255, 255, 0.2);
        }

        .leaderboard-item.normal {
            color: #95a5a6;
        }

        .delete-icon {
            cursor: pointer;
            font-size: 20px;
            color: #e74c3c;
            transition: all 0.3s;
            margin-left: 10px;
        }

        .delete-icon:hover {
            color: #c0392b;
            transform: scale(1.2);
        }

        .input-field {
            padding: clamp(10px, 1.5vw, 12px) clamp(15px, 2vw, 20px);
            font-size: clamp(14px, 2vw, 18px);
            border: 2px solid #3498db;
            border-radius: 5px;
            margin: 10px;
            width: clamp(250px, 60vw, 300px);
            max-width: 90%;
        }

        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: clamp(18px, 3vw, 24px);
            font-weight: bold;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(15px, 2vw, 20px) clamp(30px, 4vw, 40px);
            border-radius: 10px;
            pointer-events: none;
        }

        .theme-option {
            margin: 20px 0;
            padding: clamp(12px, 2vw, 15px);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        .theme-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .theme-option.selected {
            background: rgba(52, 152, 219, 0.5);
            border: 2px solid #3498db;
        }

        .error-message {
            color: #e74c3c;
            font-size: clamp(12px, 1.5vw, 14px);
            margin-top: 10px;
            min-height: 20px;
        }

        .admin-link {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #3498db;
            font-size: clamp(12px, 1.5vw, 14px);
            cursor: pointer;
            text-decoration: underline;
        }

        .admin-link:hover {
            color: #2980b9;
        }

        .setting-group {
            margin: 20px 0;
            width: 100%;
            max-width: 500px;
        }

        .setting-label {
            color: white;
            font-size: clamp(14px, 2vw, 18px);
            margin-bottom: 10px;
            font-weight: bold;
        }

        .dropdown {
            width: 100%;
            padding: clamp(10px, 1.5vw, 12px);
            font-size: clamp(14px, 2vw, 18px);
            border-radius: 5px;
            border: 2px solid #3498db;
            background: white;
        }

        .settings-scroll {
            max-height: 60vh;
            overflow-y: auto;
            padding: 0 clamp(10px, 2vw, 20px);
            width: 100%;
        }

        .logout-button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .logout-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        h1 {
            font-size: clamp(24px, 5vw, 36px);
            margin-bottom: 20px;
        }

        h2 {
            font-size: clamp(20px, 4vw, 28px);
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="320" height="320"></canvas>
        
        <div id="usernameMenu" class="menu hidden">
            <h1>Welcome to Snake Game</h1>
            <p style="font-size: 18px; margin-bottom: 20px;">Enter your username to continue</p>
            <input type="text" id="usernameInput" class="input-field" placeholder="Enter username" maxlength="20">
            <div class="error-message" id="usernameError"></div>
            <button class="button small-button" onclick="submitUsername()">Submit</button>
            <div class="admin-link" onclick="showAdminLogin()">Press here if you're an admin</div>
        </div>

        <div id="adminLoginMenu" class="menu hidden">
            <h2>Admin Login</h2>
            <input type="text" id="adminUsername" class="input-field" placeholder="Username">
            <input type="password" id="adminPassword" class="input-field" placeholder="Password">
            <div class="error-message" id="adminError"></div>
            <button class="button small-button" onclick="submitAdminLogin()">Login</button>
            <div class="close-button" onclick="backToUsernameMenu()">√ó</div>
        </div>

        <div id="startMenu" class="menu hidden">
            <h1>Snake Game</h1>
            <button class="button" onclick="startGame()">Play</button>
            <div class="username-label" id="usernameDisplay"></div>
            <div class="highscore-text" id="highscoreDisplay">HighScore: 0</div>
            <button class="button small-button" onclick="showLeaderboard()">LeaderBoard</button>
            
            <div class="info-corner">
                <div>V1</div>
                <div>MadeBy Flwl3y</div>
            </div>
            
            <svg class="settings-icon" onclick="showSettings()" viewBox="0 0 24 24" fill="white">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
            </svg>
        </div>

        <div id="settingsMenu" class="menu hidden">
            <h2>Settings</h2>
            <div class="settings-scroll">
                <p style="font-size: 18px; margin-bottom: 20px;">Choose Food Theme</p>
                
                <div class="theme-option" id="defaultTheme" onclick="selectTheme('default')">
                    <div style="font-size: 20px; margin-bottom: 10px;">Default Theme</div>
                    <div>üçé Normal Food (1 point)</div>
                    <div>üçè Rare Food (5 points, 2% chance)</div>
                </div>
                
                <div class="theme-option" id="fastfoodTheme" onclick="selectTheme('fastfood')">
                    <div style="font-size: 20px; margin-bottom: 10px;">Fast Food Theme</div>
                    <div>üçî Normal Food (1 point)</div>
                    <div>üçï Rare Food (5 points, 2% chance)</div>
                </div>

                <div class="setting-group">
                    <div class="setting-label">Snake Color</div>
                    <select class="dropdown" id="skinSelect" onchange="changeSkin()">
                        <option value="green">Green</option>
                        <option value="blue">Blue</option>
                        <option value="red">Red</option>
                    </select>
                </div>
            </div>

            <button class="logout-button" onclick="logout()">Logout</button>
            
            <div class="close-button" onclick="closeSettings()">√ó</div>
        </div>

        <div id="leaderboardMenu" class="menu hidden">
            <h2>World Leaderboard</h2>
            <div class="leaderboard-list" id="leaderboardList"></div>
            <div class="close-button" onclick="closeLeaderboard()">√ó</div>
        </div>

        <div id="gameOverMenu" class="menu hidden">
            <h2>Game Over!</h2>
            <p style="font-size: 24px; margin: 20px 0;" id="finalScore"></p>
            <button class="button" onclick="returnToMenu()">Return to Menu</button>
        </div>

        <div id="startMessage" class="game-message hidden">
            Press an arrow key to start
        </div>

        <div id="pauseMessage" class="game-message hidden">
            PAUSED<br><small style="font-size: 16px;">Press SPACE to continue</small>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const tileCount = 16;

        let gameData = {
            username: null,
            highScore: 0,
            theme: 'default',
            deviceId: null,
            isAdmin: false,
            snakeSkin: 'green'
        };

        const skinColors = {
            green: 'GreenBODY.png',
            blue: 'BlueBODY.png',
            red: 'RedBODY.png'
        };

        // Load snake images
        const snakeHeadImages = {};
        const snakeHeadOpenImages = {};
        const snakeBodyImages = {};

        ['green', 'blue', 'red'].forEach(color => {
            const colorCap = color.charAt(0).toUpperCase() + color.slice(1);
            
            snakeHeadImages[color] = new Image();
            snakeHeadImages[color].src = `${colorCap}Snake.png`;
            
            snakeHeadOpenImages[color] = new Image();
            snakeHeadOpenImages[color].src = `${colorCap}SnakeOpen.png`;
            
            snakeBodyImages[color] = new Image();
            snakeBodyImages[color].src = `${colorCap}BODY.png`;
        });

        // Load sounds
        const sounds = {
            eating: new Audio('Eating.mp3'),
            gameOver: new Audio('GameOver.mp3'),
            keyPressed: new Audio('KeyPressed.mp3')
        };

        function playSound(name) {
            try {
                sounds[name].currentTime = 0;
                sounds[name].play().catch(e => console.log('Sound play failed'));
            } catch (e) {}
        }

        let snake = [];
        let snakePositions = []; // Smooth positions for each segment
        let direction = { x: 0, y: 0 };
        let food = { x: 10, y: 10, value: 1, emoji: 'üçé' };
        let score = 0;
        let gameRunning = false;
        let gameStarted = false;
        let gamePaused = false;
        let gameLoop = null;
        let lastUpdateTime = 0;
        let animationFrameId = null;
        let moveProgress = 0;

        function getLocalData(key) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : null;
            } catch (e) {
                return null;
            }
        }

        function setLocalData(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
                return true;
            } catch (e) {
                return false;
            }
        }

        function getAllLeaderboardData() {
            return getLocalData('snakeGame_globalLeaderboard') || [];
        }

        function saveToGlobalLeaderboard(username, score) {
            let leaderboard = getAllLeaderboardData();
            const existingIndex = leaderboard.findIndex(entry => entry.username === username);
            
            if (existingIndex >= 0) {
                if (score > leaderboard[existingIndex].score) {
                    leaderboard[existingIndex].score = score;
                    leaderboard[existingIndex].timestamp = Date.now();
                }
            } else {
                leaderboard.push({
                    username: username,
                    score: score,
                    timestamp: Date.now()
                });
            }
            
            leaderboard.sort((a, b) => b.score - a.score);
            setLocalData('snakeGame_globalLeaderboard', leaderboard);
        }

        function deleteUserFromLeaderboard(username) {
            let leaderboard = getAllLeaderboardData();
            leaderboard = leaderboard.filter(entry => entry.username !== username);
            setLocalData('snakeGame_globalLeaderboard', leaderboard);
            
            let allUsers = getLocalData('snakeGame_allUsers') || [];
            allUsers = allUsers.filter(user => user !== username);
            setLocalData('snakeGame_allUsers', allUsers);
        }

        function isUsernameTaken(username) {
            if (username === 'Flowl3yStaff') return false;
            
            const leaderboard = getAllLeaderboardData();
            const allUsers = getLocalData('snakeGame_allUsers') || [];
            
            return leaderboard.some(entry => entry.username.toLowerCase() === username.toLowerCase()) ||
                   allUsers.some(user => user.toLowerCase() === username.toLowerCase());
        }

        function registerUsername(username) {
            const allUsers = getLocalData('snakeGame_allUsers') || [];
            if (!allUsers.includes(username)) {
                allUsers.push(username);
                setLocalData('snakeGame_allUsers', allUsers);
            }
        }

        function freeUsername(username) {
            let allUsers = getLocalData('snakeGame_allUsers') || [];
            allUsers = allUsers.filter(user => user !== username);
            setLocalData('snakeGame_allUsers', allUsers);
        }

        function init() {
            generateDeviceId();
            loadGameData();
            
            if (!gameData.username) {
                showMenu('usernameMenu');
            } else {
                showMenu('startMenu');
                updateStartMenuDisplay();
            }

            document.addEventListener('keydown', handleKeyPress);
            drawGrid();
            syncLeaderboardPeriodically();
        }

        function generateDeviceId() {
            let deviceId = localStorage.getItem('snakeGameDeviceId');
            if (!deviceId) {
                deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + Date.now();
                localStorage.setItem('snakeGameDeviceId', deviceId);
            }
            gameData.deviceId = deviceId;
        }

        function loadGameData() {
            const savedData = getLocalData('gameData_' + gameData.deviceId);
            if (savedData) {
                gameData.username = savedData.username;
                gameData.highScore = savedData.highScore || 0;
                gameData.theme = savedData.theme || 'default';
                gameData.isAdmin = savedData.isAdmin || false;
                gameData.snakeSkin = savedData.snakeSkin || 'green';
            }
        }

        function saveGameData() {
            setLocalData('gameData_' + gameData.deviceId, gameData);
        }

        function updateLeaderboard() {
            if (score > 0 && gameData.username) {
                const finalScore = Math.max(score, gameData.highScore);
                saveToGlobalLeaderboard(gameData.username, finalScore);
            }
        }

        function getLeaderboard() {
            return getAllLeaderboardData();
        }

        function syncLeaderboardPeriodically() {
            setInterval(() => {
                if (gameData.highScore > 0 && gameData.username) {
                    saveToGlobalLeaderboard(gameData.username, gameData.highScore);
                }
            }, 300000);
        }

        function showAdminLogin() {
            showMenu('adminLoginMenu');
        }

        function backToUsernameMenu() {
            document.getElementById('adminError').textContent = '';
            showMenu('usernameMenu');
        }

        function submitAdminLogin() {
            const username = document.getElementById('adminUsername').value.trim();
            const password = document.getElementById('adminPassword').value;
            const errorElement = document.getElementById('adminError');
            
            if (username === 'Flowl3yStaff' && password === 'Flowl3yIsRunning!') {
                gameData.username = username;
                gameData.isAdmin = true;
                registerUsername(username);
                saveGameData();
                errorElement.textContent = '';
                showMenu('startMenu');
                updateStartMenuDisplay();
            } else {
                errorElement.textContent = 'Invalid credentials';
            }
        }

        function submitUsername() {
            const username = document.getElementById('usernameInput').value.trim();
            const errorElement = document.getElementById('usernameError');
            
            if (username.length < 1) {
                errorElement.textContent = 'Please enter a username';
                return;
            }
            
            if (username.length < 3) {
                errorElement.textContent = 'Username must be at least 3 characters';
                return;
            }
            
            if (isUsernameTaken(username)) {
                errorElement.textContent = 'Username already taken. Please choose another.';
                return;
            }
            
            gameData.username = username;
            registerUsername(username);
            saveGameData();
            
            errorElement.textContent = '';
            showMenu('startMenu');
            updateStartMenuDisplay();
        }

        function updateStartMenuDisplay() {
            document.getElementById('usernameDisplay').textContent = gameData.username;
            document.getElementById('highscoreDisplay').textContent = `HighScore: ${gameData.highScore}`;
            updateThemeSelection();
            updateSkinSelection();
        }

        function showMenu(menuId) {
            const menus = ['usernameMenu', 'adminLoginMenu', 'startMenu', 'settingsMenu', 'leaderboardMenu', 'gameOverMenu', 'startMessage', 'pauseMessage'];
            menus.forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            document.getElementById(menuId).classList.remove('hidden');
        }

        function startGame() {
            showMenu('startMessage');
            gameStarted = false;
            gameRunning = false;
            gamePaused = false;
            score = 0;
            direction = { x: 0, y: 0 };
            moveProgress = 0;
            
            snake = [
                { x: 8, y: 8 },
                { x: 7, y: 8 },
                { x: 6, y: 8 }
            ];

            // Initialize smooth positions
            snakePositions = snake.map(seg => ({
                x: seg.x * gridSize,
                y: seg.y * gridSize
            }));
            
            spawnFood();
            draw();
        }

        function actuallyStartGame() {
            gameStarted = true;
            gameRunning = true;
            gamePaused = false;
            lastUpdateTime = Date.now();
            moveProgress = 1;
            document.getElementById('startMessage').classList.add('hidden');
            
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 200);
            
            animate();
        }

        function animate() {
            if (gameRunning && !gamePaused) {
                const now = Date.now();
                const delta = now - lastUpdateTime;
                moveProgress = Math.min(delta / 200, 1);
                
                updateSmoothPositions();
                draw();
                animationFrameId = requestAnimationFrame(animate);
            }
        }

        function updateSmoothPositions() {
            // Update head position with smooth interpolation
            const headTarget = {
                x: snake[0].x * gridSize,
                y: snake[0].y * gridSize
            };

            if (!snakePositions[0]) {
                snakePositions[0] = { ...headTarget };
            }

            const prevHeadX = snakePositions[0].x;
            const prevHeadY = snakePositions[0].y;
            
            snakePositions[0].x = prevHeadX + (headTarget.x - prevHeadX) * moveProgress;
            snakePositions[0].y = prevHeadY + (headTarget.y - prevHeadY) * moveProgress;

            // Update body segments - follow the segment in front
            for (let i = 1; i < snake.length; i++) {
                if (!snakePositions[i]) {
                    snakePositions[i] = {
                        x: snake[i].x * gridSize,
                        y: snake[i].y * gridSize
                    };
                }

                const target = {
                    x: snake[i].x * gridSize,
                    y: snake[i].y * gridSize
                };

                const dx = target.x - snakePositions[i].x;
                const dy = target.y - snakePositions[i].y;

                snakePositions[i].x += dx * moveProgress;
                snakePositions[i].y += dy * moveProgress;
            }
        }

        function togglePause() {
            if (!gameStarted || !gameRunning) return;
            
            gamePaused = !gamePaused;
            
            if (gamePaused) {
                document.getElementById('pauseMessage').classList.remove('hidden');
                clearInterval(gameLoop);
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            } else {
                document.getElementById('pauseMessage').classList.add('hidden');
                lastUpdateTime = Date.now();
                gameLoop = setInterval(update, 200);
                animate();
            }
        }

        function handleKeyPress(e) {
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                if (gameStarted && gameRunning) {
                    playSound('keyPressed');
                    togglePause();
                }
                return;
            }

            if (!gameStarted && !gameRunning && document.getElementById('startMessage').classList.contains('hidden') === false) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    playSound('keyPressed');
                    
                    if (e.key === 'ArrowUp') direction = { x: 0, y: -1 };
                    else if (e.key === 'ArrowDown') direction = { x: 0, y: 1 };
                    else if (e.key === 'ArrowLeft') direction = { x: -1, y: 0 };
                    else if (e.key === 'ArrowRight') direction = { x: 1, y: 0 };
                    
                    actuallyStartGame();
                }
                return;
            }

            if (!gameRunning) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
                return;
            }

            if (gamePaused) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
                return;
            }

            if (e.key === 'ArrowUp' && direction.y === 0) {
                playSound('keyPressed');
                direction = { x: 0, y: -1 };
                e.preventDefault();
            } else if (e.key === 'ArrowDown' && direction.y === 0) {
                playSound('keyPressed');
                direction = { x: 0, y: 1 };
                e.preventDefault();
            } else if (e.key === 'ArrowLeft' && direction.x === 0) {
                playSound('keyPressed');
                direction = { x: -1, y: 0 };
                e.preventDefault();
            } else if (e.key === 'ArrowRight' && direction.x === 0) {
                playSound('keyPressed');
                direction = { x: 1, y: 0 };
                e.preventDefault();
            }
        }

        function update() {
            if (!gameRunning || gamePaused) return;

            lastUpdateTime = Date.now();
            moveProgress = 0;

            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            // Check wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // Check self collision (ignore first segment as it's the new head position)
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);
            snakePositions.unshift({
                x: snakePositions[0].x,
                y: snakePositions[0].y
            });

            if (head.x === food.x && head.y === food.y) {
                score += food.value;
                playSound('eating');
                spawnFood();
            } else {
                snake.pop();
                snakePositions.pop();
            }
        }

        function spawnFood() {
            const isRare = Math.random() < 0.02;
            food.value = isRare ? 5 : 1;
            
            if (gameData.theme === 'fastfood') {
                food.emoji = isRare ? 'üçï' : 'üçî';
            } else {
                food.emoji = isRare ? 'üçè' : 'üçé';
            }

            do {
                food.x = Math.floor(Math.random() * tileCount);
                food.y = Math.floor(Math.random() * tileCount);
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function isNearFood() {
            const head = snake[0];
            const dx = Math.abs(head.x - food.x);
            const dy = Math.abs(head.y - food.y);
            return dx <= 1 && dy <= 1;
        }

        function draw() {
            drawGrid();

            ctx.font = `${gridSize - 2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(food.emoji, food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2);

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Get snake color
            const skinType = getCurrentSnakeColor();
            let bodyColor;
            if (skinType === 'green') bodyColor = '#2ecc71';
            else if (skinType === 'blue') bodyColor = '#3498db';
            else if (skinType === 'red') bodyColor = '#e74c3c';

            // Draw connected body line
            ctx.strokeStyle = bodyColor;
            ctx.lineWidth = gridSize - 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            for (let i = 0; i < snakePositions.length; i++) {
                const x = snakePositions[i].x + gridSize / 2;
                const y = snakePositions[i].y + gridSize / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Draw body circles (smaller towards tail)
            for (let i = snakePositions.length - 1; i > 0; i--) {
                const x = snakePositions[i].x + gridSize / 2;
                const y = snakePositions[i].y + gridSize / 2;
                
                // Make tail progressively smaller
                const sizeRatio = Math.max(0.5, 1 - (i / snakePositions.length) * 0.3);
                const radius = (gridSize / 2 - 2) * sizeRatio;
                
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw head
            if (snakePositions.length > 0) {
                const headX = snakePositions[0].x;
                const headY = snakePositions[0].y;
                const centerX = headX + gridSize / 2;
                const centerY = headY + gridSize / 2;
                
                const headImg = isNearFood() ? snakeHeadOpenImages[skinType] : snakeHeadImages[skinType];

                if (headImg.complete) {
                    ctx.save();
                    ctx.translate(centerX, centerY);

                    let angle = 0;
                    if (direction.x === 1) angle = 0;
                    else if (direction.x === -1) angle = Math.PI;
                    else if (direction.y === 1) angle = Math.PI / 2;
                    else if (direction.y === -1) angle = -Math.PI / 2;
                    ctx.rotate(angle);

                    ctx.drawImage(headImg, -gridSize / 2, -gridSize / 2, gridSize, gridSize);
                    ctx.restore();
                } else {
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, gridSize / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 4;
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.shadowBlur = 0;
        }

        function drawSnakeHeadSmooth(segment, progress) {
            let x = segment.x * gridSize;
            let y = segment.y * gridSize;

            // Smooth interpolation from previous position
            if (progress < 1 && snake.length > 1) {
                const prevX = (segment.x - direction.x) * gridSize;
                const prevY = (segment.y - direction.y) * gridSize;
                x = prevX + (x - prevX) * progress;
                y = prevY + (y - prevY) * progress;
            }

            const centerX = x + gridSize / 2;
            const centerY = y + gridSize / 2;
            const skinType = getCurrentSnakeColor();
            
            const headImg = isNearFood() ? snakeHeadOpenImages[skinType] : snakeHeadImages[skinType];

            if (!headImg.complete) {
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(centerX, centerY, gridSize / 2 - 1, 0, Math.PI * 2);
                ctx.fill();
                return;
            }

            ctx.save();
            ctx.translate(centerX, centerY);

            let angle = 0;
            if (direction.x === 1) angle = 0;
            else if (direction.x === -1) angle = Math.PI;
            else if (direction.y === 1) angle = Math.PI / 2;
            else if (direction.y === -1) angle = -Math.PI / 2;
            ctx.rotate(angle);

            ctx.drawImage(headImg, -gridSize / 2, -gridSize / 2, gridSize, gridSize);

            ctx.restore();
        }

        function drawSnakeBodySmooth(segment, index, progress) {
            // This function is no longer used but kept for compatibility
        }

        function getCurrentSnakeColor() {
            return gameData.snakeSkin;
        }

        function gameOver() {
            gameRunning = false;
            gameStarted = false;
            gamePaused = false;
            clearInterval(gameLoop);
            gameLoop = null;
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Play game over sound
            try {
                sounds.gameOver.currentTime = 0;
                sounds.gameOver.play().catch(e => console.log('GameOver sound failed'));
            } catch (e) {
                console.log('Sound error');
            }

            if (score > gameData.highScore) {
                gameData.highScore = score;
                saveGameData();
            }

            updateLeaderboard();

            document.getElementById('pauseMessage').classList.add('hidden');
            document.getElementById('finalScore').textContent = `You died at ${score} points`;
            showMenu('gameOverMenu');
        }

        function returnToMenu() {
            showMenu('startMenu');
            updateStartMenuDisplay();
            drawGrid();
        }

        function showLeaderboard() {
            const leaderboard = getLeaderboard();
            const listElement = document.getElementById('leaderboardList');
            listElement.innerHTML = '';

            if (leaderboard.length === 0) {
                listElement.innerHTML = '<div style="text-align: center; color: #95a5a6;">No scores yet</div>';
            } else {
                leaderboard.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = index < 3 ? 'leaderboard-item top3' : 'leaderboard-item normal';
                    
                    const leftSpan = document.createElement('span');
                    leftSpan.textContent = `${index + 1}. ${entry.username}`;
                    
                    const rightDiv = document.createElement('div');
                    rightDiv.style.display = 'flex';
                    rightDiv.style.alignItems = 'center';
                    
                    const scoreSpan = document.createElement('span');
                    scoreSpan.textContent = entry.score;
                    rightDiv.appendChild(scoreSpan);
                    
                    if (gameData.isAdmin) {
                        const deleteIcon = document.createElement('span');
                        deleteIcon.className = 'delete-icon';
                        deleteIcon.textContent = 'üóëÔ∏è';
                        deleteIcon.onclick = () => {
                            if (confirm(`Delete ${entry.username} from leaderboard?`)) {
                                deleteUserFromLeaderboard(entry.username);
                                showLeaderboard();
                            }
                        };
                        rightDiv.appendChild(deleteIcon);
                    }
                    
                    item.appendChild(leftSpan);
                    item.appendChild(rightDiv);
                    listElement.appendChild(item);
                });
            }

            showMenu('leaderboardMenu');
        }

        function closeLeaderboard() {
            showMenu('startMenu');
        }

        function showSettings() {
            showMenu('settingsMenu');
        }

        function closeSettings() {
            showMenu('startMenu');
        }

        function selectTheme(theme) {
            gameData.theme = theme;
            saveGameData();
            updateThemeSelection();
        }

        function updateThemeSelection() {
            document.getElementById('defaultTheme').classList.remove('selected');
            document.getElementById('fastfoodTheme').classList.remove('selected');
            
            if (gameData.theme === 'fastfood') {
                document.getElementById('fastfoodTheme').classList.add('selected');
            } else {
                document.getElementById('defaultTheme').classList.add('selected');
            }
        }

        function changeSkin() {
            const skin = document.getElementById('skinSelect').value;
            gameData.snakeSkin = skin;
            saveGameData();
        }

        function updateSkinSelection() {
            document.getElementById('skinSelect').value = gameData.snakeSkin;
        }

        function logout() {
            if (confirm('Are you sure you want to logout? Your username will be freed for others to use.')) {
                freeUsername(gameData.username);
                localStorage.removeItem('gameData_' + gameData.deviceId);
                gameData.username = null;
                gameData.highScore = 0;
                gameData.isAdmin = false;
                gameData.snakeSkin = 'green';
                showMenu('usernameMenu');
            }
        }

        init();
    </script>
</body>
</html>